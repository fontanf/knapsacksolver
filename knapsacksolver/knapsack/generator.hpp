#pragma once

#include "knapsacksolver/knapsack/instance.hpp"

namespace knapsacksolver
{
namespace knapsack
{

typedef int_fast64_t Seed;

/**
 * The item number is n.
 *
 * Weights:
 * wj ~ U[1, r]                     if !normal
 *    ~ N(r / 2, r / dw), wj >= 1   otherwise
 *
 * The profits depend on the value of t:
 * - "u" (uniform)
 *      pj ~ U(1, r)
 * - "wc" (weakly correlated)
 *      pj ~ U(wj - r / 10, wj + r / 10), pj >= 1
 * - "sc" (strongly correlated)
 *      pj = wj + r / 10
 * - "isc" (inverse strongly correlated)
 *      pj ~ U(1, r) if !normal else pj ~ N(r / 2, r / dw), pj >= 1
 *      wj = wj - r / 10
 * - "asc" (almost strongly correlated)
 *      pj ~ U(wj + r / 10 - r / 500, wj + r / 10 - r / 500)
 * - "sw" (similar weights)
 *      wj ~ U(r, r + r / 1000)
 *      pj ~ U(1, r / 100)
 * - "ss" (subset sum)
 *      pj = wj
 * - "mstr" (multiple strongly correlated)
 *      pj = wj + k1 if wj is divisble by d
 *           wj + k2 otherwise
 * - "pceil" (profit ceiling)
 *      pj = d ⌈wj / d⌉
 * - "circle" (circle)
 *      pj = d sqrt(4r^2 - (wj - 2r)^2)
 * - "normal" (normal)
 *      pj ~ N(r / 2, r / d)
 *
 * If spanner == true, v items with
 *      wj0 ~ U(1, r)
 *      pj0 according to type
 *      wj = ⌈2 wj0 / m⌉
 *      pj = ⌈2 pj0 / m⌉
 *  are generated.
 *  The the n items are generated by repeatedly choosing one of those items
 *  (wk, pk) such that
 *      mj ~ U(1, m)
 *      wj = mj wk
 *      pj = mj pk
 *
 * The capacity c is computed as follows:
 *   c = max(wmax, sum(wj) * h / (hmax + 1))
 * of if h = -1:
 *   c = r * (1 - x) + wsum * x
 *
 * The seed used for the random generator is s.
 *
 */
class Generator
{

public:

    ItemIdx n = 1000;
    bool normal = false;
    double dw = 10;
    std::string t = "u";
    Profit r = 1000;
    ItemIdx v = 2;
    Profit m = 10;
    ItemIdx k1 = 300; // 3*R / 10
    ItemIdx k2 = 200; // 2*R / 10
    double d = 6;
    bool spanner = false;
    int h = -1;
    int hmax = 100;
    double x = -1;
    Seed s = 0;

    /**
     * t: "u", "wc", "sc", "isc", "asc", "sw" or "ss"
     */
    static Generator classical_generator(std::string type, Profit r)
    {
        Generator d;
        d.r = r;
        d.t = type;
        return d;
    };

    static Generator spanner_generator(std::string type, Profit r, ItemIdx v, Profit m)
    {
        Generator d;
        d.r = r;
        d.t = type;
        d.spanner = true;
        d.v = v;
        d.m = m;
        return d;
    };

    static Generator mstr_generator(Profit r, ItemIdx k1, ItemIdx k2, double d)
    {
        Generator data;
        data.t = "mstr";
        data.r = r;
        data.k1 = k1;
        data.k2 = k2;
        data.d = d;
        return data;
    };

    static Generator pceil_generator(Profit r, double d)
    {
        Generator data;
        data.t = "pceil";
        data.r = r;
        data.d = d;
        return data;
    };

    static Generator circle_generator(Profit r, double d)
    {
        Generator data;
        data.t = "circle";
        data.r = r;
        data.d = d;
        return data;
    };

    static Generator normal_generator(Profit r, double d = 10)
    {
        Generator data;
        data.normal = true;
        data.dw = d;
        data.t = "normal";
        data.r = r;
        data.d = d;
        return data;
    };

    Instance generate();

private:

    std::mt19937_64 g;
    std::pair<Weight, Profit> item();
    Weight weight();
    Instance generate_standard();
    Instance generate_spanner();

};

std::ostream& operator<<(std::ostream& os, const Generator& data);

}
}

